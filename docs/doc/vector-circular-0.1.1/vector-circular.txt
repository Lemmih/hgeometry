-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | circular vectors
--   
--   nonempty circular vector data structure library. indexing always total
@package vector-circular
@version 0.1.1

module Data.Vector.Circular

-- | A circular, immutable vector. This type is equivalent to
--   <tt><a>cycle</a> xs</tt> for some finite, nonempty <tt>xs</tt>, but
--   with <i>O(1)</i> access and <i>O(1)</i> rotations. Indexing into this
--   type is always total.
data CircularVector a
CircularVector :: {-# UNPACK #-} !NonEmptyVector a -> {-# UNPACK #-} !Int -> CircularVector a
[vector] :: CircularVector a -> {-# UNPACK #-} !NonEmptyVector a
[rotation] :: CircularVector a -> {-# UNPACK #-} !Int

-- | Construct a singleton 'CircularVector.
singleton :: a -> CircularVector a

-- | Construct a <a>Vector</a> from a <a>CircularVector</a>.
toVector :: CircularVector a -> Vector a

-- | Construct a <a>NonEmptyVector</a> from a <a>CircularVector</a>.
toNonEmptyVector :: CircularVector a -> NonEmptyVector a

-- | Construct a <a>CircularVector</a> from a <a>NonEmptyVector</a>.
fromVector :: NonEmptyVector a -> CircularVector a

-- | Construct a <a>CircularVector</a> from a <a>Vector</a>.
--   
--   Calls <tt><a>error</a></tt> if the input vector is empty.
unsafeFromVector :: Vector a -> CircularVector a

-- | Construct a <a>CircularVector</a> from a list.
fromList :: [a] -> Maybe (CircularVector a)

-- | Construct a <a>CircularVector</a> from a list with a size hint.
fromListN :: Int -> [a] -> Maybe (CircularVector a)

-- | Construct a <a>CircularVector</a> from a list.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty.
unsafeFromList :: [a] -> CircularVector a

-- | Construct a <a>CircularVector</a> from a list with a size hint.
--   
--   Calls <tt><a>error</a></tt> if the input list is empty, or if the size
--   hint is <tt><a>&lt;=</a> 0</tt>.
unsafeFromListN :: Int -> [a] -> CircularVector a

-- | Construct a <a>CircularVector</a> at compile-time using typed Template
--   Haskell.
vec :: Lift a => [a] -> Q (TExp (CircularVector a))

-- | Rotate the vector to the left by <tt>n</tt> number of elements.
--   
--   <i>Note</i>: Left rotations start to break down due to arithmetic
--   underflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
rotateLeft :: Int -> CircularVector a -> CircularVector a

-- | Rotate the vector to left by <tt>n</tt> number of elements.
--   
--   <i>Note</i>: Right rotations start to break down due to arithmetic
--   overflow when the size of the input vector is <tt><a>&gt;</a>
--   <a>maxBound</a> </tt><a>Int</a>@
rotateRight :: Int -> CircularVector a -> CircularVector a

equivalent :: Ord a => CircularVector a -> CircularVector a -> Bool

canonise :: Ord a => CircularVector a -> CircularVector a

leastRotation :: forall a. Ord a => Vector a -> Int

-- | Lazily-accumulating monoidal fold over a <a>CircularVector</a>. @since
--   0.1
foldMap :: Monoid m => (a -> m) -> CircularVector a -> m

-- | Strictly-accumulating monoidal fold over a <a>CircularVector</a>.
foldMap' :: Monoid m => (a -> m) -> CircularVector a -> m

foldr :: (a -> b -> b) -> b -> CircularVector a -> b

foldl :: (b -> a -> b) -> b -> CircularVector a -> b

foldr' :: (a -> b -> b) -> b -> CircularVector a -> b

foldl' :: (b -> a -> b) -> b -> CircularVector a -> b

foldr1 :: (a -> a -> a) -> CircularVector a -> a

foldl1 :: (a -> a -> a) -> CircularVector a -> a

-- | Lazily-accumulating semigroupoidal fold over a <a>CircularVector</a>.
foldMap1 :: Semigroup m => (a -> m) -> CircularVector a -> m

-- | Strictly-accumulating semigroupoidal fold over a
--   <a>CircularVector</a>.
foldMap1' :: Semigroup m => (a -> m) -> CircularVector a -> m

toNonEmpty :: CircularVector a -> NonEmpty a

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: (a -> Bool) -> CircularVector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: (a -> Bool) -> CircularVector a -> Bool

-- | <i>O(n)</i> Check if all elements are True.
and :: CircularVector Bool -> Bool

-- | <i>O(n)</i> Check if any element is True.
or :: CircularVector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
sum :: Num a => CircularVector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
product :: Num a => CircularVector a -> a

-- | <i>O(n)</i> Yield the maximum element of the circular vector.
maximum :: Ord a => CircularVector a -> a

-- | <i>O(n)</i> Yield the maximum element of a circular vector according
--   to the given comparison function.
maximumBy :: (a -> a -> Ordering) -> CircularVector a -> a

-- | <i>O(n)</i> Yield the minimum element of the circular vector.
minimum :: Ord a => CircularVector a -> a

-- | <i>O(n)</i> Yield the minimum element of a circular vector according
--   to the given comparison function.
minimumBy :: (a -> a -> Ordering) -> CircularVector a -> a

-- | <i>O(n)</i> Rotate to the minimum element of the circular vector
--   according to the given comparison function.
rotateToMinimumBy :: (a -> a -> Ordering) -> CircularVector a -> CircularVector a

-- | <i>O(n)</i> Rotate to the maximum element of the circular vector
--   according to the given comparison function.
rotateToMaximumBy :: (a -> a -> Ordering) -> CircularVector a -> CircularVector a

-- | Index into a <a>CircularVector</a>. This is always total.
index :: CircularVector a -> Int -> a

-- | Get the first element of a <a>CircularVector</a>. This is always
--   total.
head :: CircularVector a -> a

-- | Get the last element of a <a>CircularVector</a>. This is always total.
last :: CircularVector a -> a

-- | <i>O(min(m,n))</i> Zip two circular vectors with the given function.
zipWith :: (a -> b -> c) -> CircularVector a -> CircularVector b -> CircularVector c

-- | Zip three circular vectors with the given function.
zipWith3 :: (a -> b -> c -> d) -> CircularVector a -> CircularVector b -> CircularVector c -> CircularVector d

-- | <i>O(min(n,m))</i> Elementwise pairing of circular vector elements.
--   This is a special case of <a>zipWith</a> where the function argument
--   is <tt>(,)</tt>
zip :: CircularVector a -> CircularVector b -> CircularVector (a, b)

-- | Zip together three circular vectors.
zip3 :: CircularVector a -> CircularVector b -> CircularVector c -> CircularVector (a, b, c)

-- | <i>O(n)</i> Reverse a circular vector.
reverse :: CircularVector a -> CircularVector a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Circular.CircularVector a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.Circular.CircularVector a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Vector.Circular.CircularVector a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Circular.CircularVector a)
instance GHC.Generics.Generic (Data.Vector.Circular.CircularVector a)
instance GHC.Base.Functor Data.Vector.Circular.CircularVector
instance Data.Traversable.Traversable Data.Vector.Circular.CircularVector
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Circular.CircularVector a)
instance GHC.Base.Semigroup (Data.Vector.Circular.CircularVector a)
instance Data.Foldable.Foldable Data.Vector.Circular.CircularVector
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Vector.Circular.CircularVector
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Data.Vector.Circular.CircularVector a)
